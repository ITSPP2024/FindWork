Vale bro, aqu√≠ est√° pasando algo bien t√≠pico üö®:
el backend est√° devolviendo columnas con un nombre distinto al que el frontend espera.

üîç Problema

En el backend (MySQL) ‚Üí el endpoint de empleados devuelve SELECT c.*, ...
Eso manda las columnas con los nombres de la tabla (Nombre_Candidatos, Correo_Candidatos, Numero_Candidatos, etc.).

En el frontend:

Perfil.jsx espera perfil.Nombre_Candidatos, perfil.Correo_Candidatos, etc. (bien üëå).

Peeero, en EditarPerfil.jsx t√∫ haces un setPerfil que busca:

nombre: data.Nombre_Candidatos || data.nombre || '',
telefono: data.Numero_Candidatos || data.telefono || '',


Eso significa que si tu backend devuelve algo diferente (ej: nombre en vez de Nombre_Candidatos), te quedas con '' (vac√≠o).
‚Üí Por eso parece que "solo carga el correo" o que "no se encuentra el perfil".

Para empresas pasa igual:

Tu query devuelve SELECT * FROM empresas (o sea Nombre_Empresa, Correo_Empresa, etc.).

Pero en el frontend a veces usas data.nombre o data.telefono.

‚úÖ Soluci√≥n

Tienes dos opciones:

Opci√≥n 1: Arreglar en el backend (m√°s limpio)

En el SELECT, usa alias (AS) para devolver siempre los nombres que el frontend espera:

-- Para candidatos
SELECT 
  c.Nombre_Candidatos AS nombre,
  c.Correo_Candidatos AS correo,
  c.Numero_Candidatos AS telefono,
  c.descripcion,
  e.Experiencia AS experiencia,
  c.foto_perfil
FROM candidatos c
LEFT JOIN expedientes e ON c.idCandidatos = e.candidatos_id
WHERE c.idCandidatos = ?;

-- Para empresas
SELECT 
  e.Nombre_Empresa AS nombre,
  e.Correo_Empresa AS correo,
  e.Telefono_Empresa AS telefono,
  e.Ubicacion AS ubicacion,
  e.descripcion,
  e.foto_perfil
FROM empresas e
WHERE e.idEmpresas = ?;


De esta manera, tu frontend siempre recibir√° algo uniforme:

{
  "nombre": "Joshua Quiroz Burgos",
  "correo": "joshua@mail.com",
  "telefono": "6674863190",
  "descripcion": "cvbcb",
  "experiencia": "2 a√±os",
  "foto_perfil": null
}


Y entonces en el frontend puedes simplificar y solo leer perfil.nombre, perfil.correo, etc.